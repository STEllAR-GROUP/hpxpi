***************************
XPI Specification 0.9 rev74
***************************

General notes: 
    Many functions are documented as 'This (can be used) ...'. 
    Wouldn't it be more concise to use the function name instead of 'This'?

    The spec documents constructor functions for different types, but no 
    destructors. Why?

    All arguments for API functions should be const-correct.

    Are there examples demonstrating the use of this API?

    The C-API is called C-ABI throughout the document. This spec does not
    define an ABI (binary interface) but relies on the compilers ABI. It
    defines an API instead. It might be confusing to use the term C-ABI.

    What are the criteria for providing a '_sync' overload for an API 
    function?

3.2 Initialization and Shutdown
-------------------------------

XPI_INIT/XPI_RUN:
    Why are those separate? Is there a use case?

XPI_TERMINATE:
    The C API calls this XPI_finalize.
    Where does control return when this is called? Is this to be called on the 
    same thread as XPI_RUN?

3.3 High-Level Interface Routines
---------------------------------

XPI_ABORT:
    Does the specification of XPI_abort belong into 3.2 instead?
    What happens with the 'message' parameter, where will it be printed?
    Why does this return control to the XPI_RUN site? Does it make sense to 
    continue if this has been called? Is there a use case?


4.2.2 Derived Types
-------------------

    Who is responsible for releasing the data types returned from the functions
    described here? If it's the user - how are those released?

XPI_TYPE_STRUCT: 
    'XPI_Type[n] types' instead of 'XPI_Type types[n]'


4.3 Parcel Continuations
------------------------

XPI_CONTINUE: 
    'XPI_Type[n] types' instead of 'XPI_Type types[n]'

4.4 Parcel Generation
---------------------

XPI_PARCEL_CREATE:
    Who is responsible for releasing the returned parcel handle? When is it
    safe to release it? How is it released?

XPI_PARCEL_SET_DATA: 
    uses MPI_Type as argument

4.5 Apply
---------

XPI_APPLY: 
    mistyped: XPI_err
    missing: parameter 'future'

4.6 Advanced
------------

XPI_PARCEL_GET_CONT_ACTION:
    char** action: who is repsonsible for freeing the memory?

XPI_PARCEL_SELECT:
    Is this call blocking if no matching parcels are available?

XPI_PARCEL_GET_CONT_ACTION:
    char** action: who is repsonsible for freeing the memory?

XPI_PARCEL_GET_DATA_TYPE:
    XPI_Type* type: who is repsonsible for freeing the memory? If the caller 
                    is supposed to free the memory, how?

5.1 Address Space
-----------------

XPI_NULL:
    does not make sense: "The NULL global virtual address is defined such that, 
                         when compared to an address initialized with the 
                         integer, 0."

5.2 Native Interface
--------------------

    Why isn't there a 16 byte operation (for uint128_t) defined, even if the
    specification explicitly refers to uin128_t in some places?

6.2 Thread Scheduling
---------------------

XPI_Thread_State:
    different spellings used 'XPI_Thread_State' and 'XPI_Thread_state'

7.2 LCOs
--------

XPI_LCO_fini:
    This is the only ABI function which uses an abbreviation in its name.

7.3 Futures
-----------

XPI_Future_new:
    The docs mention a process the future is allocated with. But the API 
    functions do not accept any process.

7.4 User LCOs
-------------

XPI_LCO_Predicate:
    erroneous specification 'typedef bool (*XPI_Predicate)(void* lco);'


8.1.2 Main Process
------------------

XPI_MAIN:
    What are the argument types passed to 'args' in 
    'XPI_main(size_t nargs, void* args[])?' 

8.2. Action Management
----------------------

XPI_PROCESS_REGISTER_ACTION_ACTION:
    typo 'xhar* id'

8.3 Memory Management
---------------------

XPI_Distribution:
    Will this be specified or is this implementation defined?

XPI_Process_global_malloc:
    The text says that this operation is currently synchronous only, nevertheless
    both versions are given.

XPI_Process_pin:
    Last argument should be 'XPI_Addr future'

8.4 LCO Management
------------------

Is this chapter complete? Some explanations of how user defined LCOs are supposed 
to work would be helpful.

